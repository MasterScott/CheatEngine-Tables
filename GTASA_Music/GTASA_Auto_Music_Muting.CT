<?xml version="1.0" encoding="utf-8"?>
<CheatTable CheatEngineTableVersion="18">
  <Forms>
    <GTASAForm Class="TCEForm" Encoding="Ascii85">=O5A#,cpptENOMIm1+vo(UA^m,K$Jz/hx%o6h,%:s7pvHcADt{B+GR*GNF:G9rp_R3w]U=@dtJzPw9dbb+q*S$y,Cy!D4aQ#qPl[0P4=(iG/ZW,0Iz1b_Sp%,@MCQisVu^zYLPe44iT2sv9i5Nm@o%^3V$[ckG};d]vPb8w8GU.RVVZn,mNBeWyc{VIYtV9QSHP=K_8JVg/]lb1dI+*xPj}A:eax.h?IdVP=W6meC?$%R9ZY]0)IN1U-HmHrwJuXxdULw)Oy[Y-wcJ)*,Pp4:m5Qy5b(/q[Y-lH$0nrONm6JU0k.XYR@aGXfuDNxSg*;OvmPOjZIa!fhYQzIRhTgO[NL{$9%6Wf/Rn9oeZO8i/CT=oi*};B1YVcd}C-*J]H@(BOmQYWg$H:2dslQZ-#S_]D)zgNAn8;,3,^bz^3eX0kRFG2(4pL2gojvJs_r*4uBj2IRc@pDFab}RDftePJo.OIRjD!?.#8)Ky*BAAax*OAWa{_fEYkbAQq4okheh2fm^H22jmA;Iw?i*VcEg5i*9bXK9(P4hggnasnvv{QmH@vt0OrnZc9;;q$J6XB*gLANwP1:fh32L93d%5iIS8kNr^q[D4}R/lp(:wn/k^niuxK-mBx7.QfHdpMB1onkkYji3,Z[k]*gXg1+y7rfjx%oNvpc17=9S)k#tjOnHp9]wQhw}1ILW(:@3[,Xo]7OMSW=rsi,!(s=:3Y2dHSeW=^QheOs,yt)mIQ#JXBHHNyhXBQY;Et7X*(9/?!=Xy[/!qP%KB2BoT(q9fC(TQ}%nil$a.vPZkn*E2Ih)aSB%YSbZ9i/x=;rZ;:g$uyP9cFYuGrW7,fF_!+pdoi.gGY2tq7(AwZF-B].[1Lm)t*+Mlrv47H#//U^D@2sPVIkKlTZV!?WiKMp.,QKz(eWQUp.!$gG09Xio2e@N2DRMlkL2o9Ixk4XsTqrsFiPY+lki!bgkSRQOTPWj?)r*X9Ohejh_%vpu)%)^B#D}$$hS_s7pD{wn9PVo^w1qNlkQ5{/R6J}-lonRH-J}tA9}YeNW]#j):HnfxJ!jA-z%K1wwcdu+$ldzc7}pZH!/}jAm1_n,UCp@^5lg@.V-9I4,ntt/f;WLi*:]YpCP$$S-C;@.(D2=%p9@0noKTbcEyb{G?FgN,,:5x);wE)l#foqkMGUQf%$2;Goxbh^;*7K*E!b5=?+-petY!nKkw0UxNx,[c$fZx?[qIxm6(/Cu9P[,#4o.kzAopVw-GkKN::hk6;f+GQRdoXWP%$9yEY5=Lf%4b,Bh9Cp@i?j:Nd8d1!9KCI+3/SqU)MaP;C/_s1xDo?eaN#QEG!am):EdFAxLDhPET59:VP@3-QJn!j!Zx6Z+jI,,wKGX21}ST(F#nJHalUz?rGya?OYk/x[Ue-+V4*7Dx9SZi_C6-MDeNcfY8d0AC0[RYo5=zbD4g@p7{tGW#5ldY6*8Y](Gw9Mj[FHhpjNfOil[,P/aCwmt6qKQ2dTsiH5u;:XzqY82ohWS?/}G@F#chB3C^.CrijNm)awe(*x8ybLv*uIl2)Lv/dlFpRpb)$3cI[LhIcd9c4$$W#0:I^$0WHan8o5znIvB{2a@lfuuz)OF4#)P0ui8PDuE=6bF]SjSkFf+W+wJ=vgzm+Lv!GWQC^MzP#ysOgg5.Nj2[uI)4^=c:dhT1O{f]OYzI[SvoU%t4jt9L0}/$.$R/U3%jL-B2%PfyZoT:,jkPGBjp]zASA@xzPY{![Z8]1}:W^KMfrZby!]GGeq.,?#PMzh0#=UMb}ei5nbQJsH}a^caheZ+YmfEM;[^wrR{wu+jk+Hv(Yus3U3du8pB^P4C26Aa6e2)*yF=,pHD@(8Fh2%]DA_h(O76.#N4@}vLfU]#$DF#@Js@LZXdIX-ijffXsqAAr7lN!0ue(}YIJn%%-s$d*)h92,zROsg=Y@G^JY_:s^j(-yfvON[18wul9l^mc(duQZ4]p42#.QjYkzFOb2%J]::6m6iu)Fa]EV=OzrO)</GTASAForm>
  </Forms>
  <CheatEntries/>
  <UserdefinedSymbols/>
  <LuaScript>function debug(text)
    if settings:isEnabled("DebugOutputCheckbox") then
        print(text)
    end
end

----------------------
-- GTA:SA Utilities --
----------------------
GTASAUtil = {}

-- The following functions should be added to return true if these features
-- should be enabled:
--
-- self:isAutoAttachEnabled()
-- self:gameVersionDetected()
-- self:isDebugEnabled()
--
-- The following function is called when the game version has been detected:
--
-- self:gameVersionDetected(self.gameVersionDescription)


-- What to add to the relative 1.0 address to get the address for the current
-- version (e.g. also contains the process address, usually 0x400000).
GTASAUtil.gameVersionOffset = 0

-- Contains special addresses, that require more than an offset to work.
-- The key is the normal 1.0 address, the value the absolute address.
GTASAUtil.gameVersionAddr = {}

GTASAUtil.versionsDef = {
    {"008245BC",18313216,0,"1.0","1.0"},
    {"0082457C",18313216,0,"1.0","1.0"},
    {"0082533C",34471936,0x2680,"1.01","1.01"},
    {"008252FC",34471936,0x2680,"1.01","1.01"},
    {nil,17985536,0x2680,"2.0","2.0"},
    {"0085EC4A",9691136,0x75130,"3.0 Steam","3.0 Steam"},
    {"0085DEDA",0,0x75770,"1.01 Steam","1.01 Steam?"},
    {nil,9981952,0x77970,"Steam","Steam (not fully supported)"}
}

GTASAUtil.gameVersion = ""
GTASAUtil.gameVersionDescription = ""

function GTASAUtil:new()
    local object = {}
    setmetatable(object, self)
    self.__index = self
    return object
end

function GTASAUtil:debug(text)
    if self:isDebugEnabled() then
        print("[GTASAUtil] "..text)
    end
end

function GTASAUtil:init()
    self.autoAttachTimer = createTimer(nil, false)
    timer_onTimer(self.autoAttachTimer, function() self:autoAttach() end)
    timer_setInterval(self.autoAttachTimer, 5000)
    timer_setEnabled(self.autoAttachTimer, true)
end

function GTASAUtil:cleanUp()
    self:debug("Cleanup")
    object_destroy(self.autoAttachTimer)
end

function GTASAUtil:adjustAddress(addr)
    if type(addr) == "string" then
        addr = tonumber(addr)
    end
    if addr == nil then
        return nil
    end
    if self.gameVersionAddr[addr] ~= nil then
        return self.gameVersionAddr[addr]
    end
    return addr+self.gameVersionOffset
end

function GTASAUtil:getInteger(addr)
    return readInteger(self:adjustAddress(addr))
end

function GTASAUtil:getByte(addr)
    return readBytes(self:adjustAddress(addr), 1, false)
end

function GTASAUtil:getFloat(addr)
    return readFloat(self:adjustAddress(addr))
end

function GTASAUtil:autoAttach()
    if self:isAutoAttachEnabled() then
       self:attach(false)
    end
end

function GTASAUtil:attach(force)
    -- Try to read from current process to check if still available
    local testRead = readInteger(self.currentProcess)
    if testRead == nil or force then
        local names = {"gta_sa.exe", "gta-sa.exe"}
        for _,name in ipairs(names) do
            if self:tryAttach(name, force) then
                return
            end
        end
        self:gameNotFound()
    end
end

function GTASAUtil:tryAttach(process, force)
    --self:debug("Try "..process)
    local processId = getProcessIDFromProcessName(process)
    if processId == nil then
        return false
    end
    --self:debug("Check "..process.." "..processId.." "..getOpenedProcessID())
    if processId ~= getOpenedProcessID() or force then
       openProcess(process)
       self.currentProcess = process
       self:debug("Opened process "..process)
       self:detectVersion()
    end
    return true
end

function GTASAUtil:detectVersion()
    self:debug("Detect version")
    self.gameVersion = ""
    self.gameVersionOffset = 0
    self.gameVersionAddr = {}

    -- Try to detect version by address
    -- (this doesn't work when CD hasn't been checked yet)
    local target = 38079
    for _,v in ipairs(self.versionsDef) do
        if v[1] ~= nil and readInteger(v[1]) == target then
            self.gameVersion = v[4]
            self.gameVersionDescription = v[5].." [detected by address]"
            self.gameVersionOffset = v[3] + getAddress(self.currentProcess)
        end
    end

    -- Detect by module size if no version detected yet
    if self.gameVersion == "" then
        local moduleSize = getModuleSize(self.currentProcess)
        for _,v in ipairs(self.versionsDef) do
            if v[2] ~= 0 and moduleSize == v[2] then
                self.gameVersion = v[4]
                self.gameVersionDescription = v[5].." [detected by module size]"
                self.gameVersionOffset = v[3] + getAddress(self.currentProcess)
            end
        end
    end

    -- Special Addresses
    if self.gameVersion == "Steam" then
        -- Steam Version needs more than an offset for some values
        local base = getAddress(self.currentProcess)
        self.gameVersionAddr[0x68B42C] = 0x702D98 + base
        self.gameVersionAddr[0x77CB84] = 0x80FD74 + base
        self.gameVersionAddr[0x773460] = 0x8002AC + base
    end

    if self.gameVersion == "" then
        self.gameVersionDescription = "Version Unknown"
    end

    self:gameVersionDetected(self.gameVersionDescription)
end

----------------------------
-- Initialize GTA:SA Util --
----------------------------

gtasa = GTASAUtil:new()
gtasa.isAutoAttachEnabled = function()
    return true
end

gtasa.gameVersionDetected = function(self, description)
    GTASAForm.GameVersion.Caption = "Game: "..description
end

gtasa.gameNotFound = function(self)
    GTASAForm.GameVersion.Caption = "Game process not found"
end

gtasa.isDebugEnabled = function()
    return settings:isEnabled("DebugOutputCheckbox")
end


---------------------
-- Settings Helper --
---------------------

SettingsHelper = {}

-- Setting name should be the name of the element in the form
-- List of boolean setting names
SettingsHelper.booleanSettings = {}

-- List of string settings, each as {"settingName", "default setting"}
SettingsHelper.stringSettings = {}

---
-- Creates a new SettingsHelper object.
--
-- @param  string  settingsName: The name these settings are stored under
-- @param  form    form: The GUI where the setting elements are on
function SettingsHelper:new(settingsName, form, saveFormLocation)
    local object = {}
    setmetatable(object, self)
    self.__index = self
    object.settingsName = settingsName
    object.form = form
    object.saveFormLocation = saveFormLocation
    return object
end

function SettingsHelper:load()
    self.settings = getSettings(self.settingsName)
    for _,v in ipairs(self.booleanSettings) do
        self:setEnabled(v, self.settings.Value[v])
    end
    for _,v in ipairs(self.stringSettings) do
        local value = self.settings.Value[v[1]]
        if value == nil or value == "" then
           value = v[2]
        end
        self.form[v[1]].Text = value
    end
    if self.saveFormLocation then
        local formLocation = self.settings.Value["formLocation"]
        if formLocation ~= nil and value ~= "" then
            local x, y = string.match(formLocation, "(%d+),(%d+)")
            if x ~= nil and y ~= nil then
                self.form.setPosition(x, y)
                debug(string.format("[Settings] Set form position to %d,%d", x, y))
            end
        end
    end
end

function SettingsHelper:save()
    for _,v in ipairs(self.booleanSettings) do
        self.settings.Value[v] = self:isEnabled(v)
    end
    for _,v in ipairs(self.stringSettings) do
        self.settings.Value[v[1]] = self.form[v[1]].Text
    end
    local x, y = self.form.getPosition()
    self.settings.Value["formLocation"] = string.format("%d,%d", x, y)
end

function SettingsHelper:isEnabled(element)
    return self.form[element]:getState() == cbChecked
end

function SettingsHelper:setEnabled(element, enabled)
    if enabled == "1" then
        self.form[element]:setState(cbChecked)
    else
        self.form[element]:setState(cbUnchecked)
    end
end

function SettingsHelper:getValue(element)
    return self.form[element].Text
end

function SettingsHelper.getPath(str,sep)
    sep = sep or '/'
    return str:match("(.*"..sep..")")
end

function SettingsHelper:selectFilePath(sender, setting)
    local dialog = createSaveDialog(sender)
    local value = self:getValue(setting)
    dialog.Title = "Select file to write to (currently: "..value..")"
    dialog.InitialDir = SettingsHelper.getPath(value,"\\")
    dialog.execute()
    local file = dialog.FileName
    if file ~= nil and file ~= "" then
       self.form[setting].Text = file
    end
end

--------------------------------
-- Initialize Settings Helper --
--------------------------------

settings = SettingsHelper:new("gtasa_music", GTASAForm, true)

settings.booleanSettings = {
    "BeepCheckbox",
    "DebugOutputCheckbox",
    "HotkeyCheckbox"
}

settings.stringSettings = {
    {"HotkeyMute",""},
    {"HotkeyUnmute",""}
}

------------
-- Muting --
------------

local locations = {
    {"Four Dragons", 1958.0, 1017.1, 992.5, 80},
    {"Caligulas", 2236.0, 1630.6, 1008.4, 120},
    {"Bloodbowl", -1389.4, 993.2, 1023.8, 200},
    {"LS Stadium", -1388.9, -223.6, 1043.2, 200},
    {"Lowrider Dance", 1793.2, -1905.6, 13.5, 40, "sweet6"},
    {"Beach Dance", 530.4, -1889.5, 3.3, 40, "music1"},
    {"Saint Marks", -789.6, 504.9, 1371.7, 20}
}

function getActiveThreads(amount)
    local addr = gtasa:getInteger("0x68B42C")
    local output = {}
    for i = 0, amount, 1 do
        if addr == nil then
            break
        end
        local threadname = readString(addr+8, 10, false)
        if threadname == nil then
            break
        end
        table.insert(output, {addr=addr, name=threadname})
        -- Get next one
        addr = readInteger(addr)
    end
    return output
end

function isActiveThread(name)
    local threads = getActiveThreads(10)
    for _, thread in ipairs(threads) do
        if thread.name == name then
            return true
        end
    end
    return false
end

function getPlayerXYZ()
    local addr = gtasa:getInteger("0x77CD98")
    if addr == nil then
       return nil
    end
    addr = readInteger(addr+20)
    if addr == nil then
        return nil
    end
    local x = readFloat(addr+48)
    local y = readFloat(addr+52)
    local z = readFloat(addr+56)
    return x,y,z
end

function calculateDistance(x, y, z, cx, cy, cz)
    return math.sqrt((cx - x)^2 + (cy - y)^2 + (cz - z)^2)
end

local lastChangedTime = 0
local prevMute = false

function checkLocation()
    local x, y, z = getPlayerXYZ()
    if x == nil or y == nil or z == nil then
        updateState("Game not ready")
        return
    end

    local mute = false
    local closestLocation = nil
    local closestDistance = -1
    for _,location in ipairs(locations) do
        local cx = location[2]
        local cy = location[3]
        local cz = location[4]
        local radius = location[5]
        local thread = location[6]
        if prevMute then
            -- Unmute further away, to prevent constant mute/unmute
            radius = radius + 20
        end
        local distance = calculateDistance(x, y, z, cx, cy, cz)
        if distance &lt; radius then
            if thread == nil or isActiveThread(thread) then
                mute = true
            end
        end

        if closestDistance == -1 or distance &lt; closestDistance then
            closestDistance = distance
            closestLocation = location
        end
    end

    -- Actual muting/unmuting
    if mute ~= prevMute then
        setMute(mute)
        lastChangedTime = os.clock()
    end
    prevMute = mute

    -- Create status output
    local state = "Muted"
    if not mute then
        state = "Unmuted"
    end
    if os.clock() - lastChangedTime &lt; 4 then
        state = "**"..state.."**"
    end
    local thread = closestLocation[6]
    if thread ~= nil then thread = "/"..thread else thread = "" end
    local name = closestLocation[1]
    local radius = closestLocation[5]
    updateState(string.format("%s (%s/%.f/%.f%s)",
        state, name, closestDistance, radius, thread))
end

function setMute(mute)
    if settings:isEnabled("BeepCheckbox") then
        if mute then
            triggerHotkey(mute)
            sleep(50)
            beep()
        else
            beep()
            sleep(100)
            beep()
            sleep(700)
            triggerHotkey(mute)
        end
    else
        triggerHotkey(mute)
    end
end

function triggerHotkey(mute)
    local hotkey
    if mute then
        hotkey = _G["VK_"..settings:getValue("HotkeyMute")]
    else
        hotkey = _G["VK_"..settings:getValue("HotkeyUnmute")]
    end
    if settings:isEnabled("HotkeyCheckbox") and hotkey ~= nil then
        doKeyPress(hotkey)
    end
end

function updateState(state)
    GTASAForm.CurrentState.Caption = state
end

------------------
-- Timer / Init --
------------------

local slowTimer

function slowTimerCallback()
    local hotkeyEnabled = settings:isEnabled("HotkeyCheckbox")
    local beepEnabled = settings:isEnabled("BeepCheckbox")
    local debugEnabled = settings:isEnabled("DebugOutputCheckbox")
    if hotkeyEnabled or beepEnabled then
        if not debugEnabled then
            -- Not debugging, call protected and just stop on error
            local success, error = pcall(checkLocation)
            if not success then
                object_destroy(slowTimer)
                updateState("Error: "..tostring(error))
            end
        else
            -- Debugging, run normally with chance of error window popping up
            checkLocation()
        end
    else
        updateState("Inactive")
    end
end

function init()
    fillKeys(GTASAForm.HotkeyMute)
    fillKeys(GTASAForm.HotkeyUnmute)
    settings:load()

    slowTimer = createTimer(nil, false)
    timer_onTimer(slowTimer, slowTimerCallback)
    timer_setInterval(slowTimer, 250)
    timer_setEnabled(slowTimer, true)

    gtasa:init()
    gtasa:attach(true)
end

local function starts_with(str, start)
   return str:sub(1, #start) == start
end

-- Fill a combo box with all defined key names (variables starting with "VK_")
function fillKeys(combo)
    combo:clear()
    local keys = {}
    for key,_ in pairs(_G) do
        if starts_with(key, "VK_") then
            table.insert(keys, key:sub(4))
        end
    end
    table.sort(keys, function(a,b)
        if a:len() == b:len() then
            return a &lt; b
        end
        return a:len() &lt; b:len()
    end)
    for _,key in ipairs(keys) do
        combo.Items.Add(key)
    end
end

-- Show GUI and init stuff
form_show(GTASAForm)
init()

-------------------
-- GUI Functions --
-------------------

GTASAForm.onClose = function(sender)
    debug("Closed")
    object_destroy(slowTimer)
    gtasa:cleanUp()
    settings:save()
    -- Only for standalone version
    --closeCE()
    return caHide
end

function TestMuteButton(sender)
    setMute(true)
end

function TestUnmuteButton(sender)
    setMute(false)
end

function CopyPlayerCoordinatesClick(sender)
    local x, y, z = getPlayerXYZ()
    if x ~= nil then
        writeToClipboard(string.format("%.1f, %.1f, %.1f",
            x, y, z))
    else
        writeToClipboard("Coordinates currently not available")
    end
end
</LuaScript>
</CheatTable>
