<?xml version="1.0" encoding="utf-8"?>
<CheatTable CheatEngineTableVersion="18">
  <Forms>
    <GTASAForm Class="TCEForm" Encoding="Ascii85">omN_O)=%3le79[8fRMoSY2Sd5At]kF.OR]qRtm^9kQA%XnLe$g6MM)/uDe:c^KxnS^0?Ff[o6#=nnn-yN[#Hf[nosx]eIv[d-eLH=K.1]W[.0o/BldHwQ5_zwW$BH);en)or(5Xb)bw]ADSOYAZGQwowkFQf-u@8EM10@5qcX)#7Co8Fu4=jPWw)sfQr/:XKpk9OX]Fyf/gC,E#u]_pm952T0IHKnSnnav)LL^Ow3]eZ$0*_Bdax1VD}k!x(c:EJHxf;ax$F*N5.G3V)+d%z-yLeqO+m@WOUo=OU!UEqW,BW2=.;uc.PTAI1Aeq0DBcPwP/(7#K%ksw%E[NC9-Wn9,a*J7;=8kxZ(uf9QQTHorGiXV9XSg$rAfg:NH/xZl4QSB:(:x=M_6)-:O%DE@gpkkYo#*g2gr;MvRR[4pJgpFv{8kCFXG}BhXzJBB2tQ,go71TYU-v9[JRu/v*}3j5blPf3-Fj?%Ogzk9ti!mm4iSSN0t_H^Mp)$Xz9XI#Zy{4DsjfiYB;o@]dh3l$ELU(Dxck.%?4dLTuNsWOhdd5B_4.J+{WgnrZl+I:PAst2BT5V{NCPZf]jwHV(y2]B8=fp,e]0o0ip*i7(7RVebuIzz5)F+/QFx))Sr8FIN:!=F7$J4;amgg8Hva?9(g.SRP2]X_0}oy!VcwsicDf5a0[4dRLgsLFcfL?lJts--*?{m/W99alD.%QNk+/#u:faPvm$!zed.;/P!]BwmMS+dV0ZDT!!Q56jL9LU%op2;Et,C0f=WU4QwPYjH.JczV,2lVAf#%q@IVU8_gP-a:6h2@RZHEU:M6O*X#!r*1U#0l.aUPJk+a54-vUW^tVNp,#=i.8K4l$NY{7J5%]P-)ZKeGSy1#(N-=ngA-W3jS{]Lsq$G#r]#R4YBze)[h=$N^BE*e).s]yJDK)fQ@!),C?:G?4D%LQiHZVl+.h(gr8N.1%z+5ZxiBtui;2CTl;82-l?21W/H3chm)XP3f%-Bkmw$n+h-STPPI_VPEUdCb;i=oHd47Fna-2A=Nl/(S+^Z%:553Ac72i;:9)B0SF+=NA.:o5i{VlM/!i/pKGMQF]pB+hKGHKHJ.7EFu#Ya.He%4lrkxz3x9#HLoEs?cYGv0TV{P[-/{b}B5?cU#w0f9kcq?37[CG?HX?K=#*_9Ay9:sqM5Giw5a?^$ZoP-jiQ(+1r</GTASAForm>
  </Forms>
  <CheatEntries/>
  <UserdefinedSymbols/>
  <LuaScript>function debug(text)
    if settings:isEnabled("DebugOutputCheckbox") then
        print(text)
    end
end

----------------------
-- GTA:SA Utilities --
----------------------
GTASAUtil = {}

-- The following functions should be added to return true if these features
-- should be enabled:
--
-- self:isAutoAttachEnabled()
-- self:gameVersionDetected()
-- self:isDebugEnabled()
--
-- The following function is called when the game version has been detected:
--
-- self:gameVersionDetected(self.gameVersionDescription)


-- What to add to the relative 1.0 address to get the address for the current
-- version (e.g. also contains the process address, usually 0x400000).
GTASAUtil.gameVersionOffset = 0

-- Contains special addresses, that require more than an offset to work.
-- The key is the normal 1.0 address, the value the absolute address.
GTASAUtil.gameVersionAddr = {}

GTASAUtil.versionsDef = {
    {"008245BC",18313216,0,"1.0","1.0"},
    {"0082457C",18313216,0,"1.0","1.0"},
    {"0082533C",34471936,0x2680,"1.01","1.01"},
    {"008252FC",34471936,0x2680,"1.01","1.01"},
    {nil,17985536,0x2680,"2.0","2.0"},
    {"0085EC4A",9691136,0x75130,"3.0 Steam","3.0 Steam"},
    {"0085DEDA",0,0x75770,"1.01 Steam","1.01 Steam?"},
    {nil,9981952,0x77970,"Steam","Steam (not fully supported)"}
}

GTASAUtil.gameVersion = ""
GTASAUtil.gameVersionDescription = ""

function GTASAUtil:new()
    local object = {}
    setmetatable(object, self)
    self.__index = self
    return object
end

function GTASAUtil:debug(text)
    if self:isDebugEnabled() then
        print("[GTASAUtil] "..text)
    end
end

function GTASAUtil:init()
    self.autoAttachTimer = createTimer(nil, false)
    timer_onTimer(self.autoAttachTimer, function() self:autoAttach() end)
    timer_setInterval(self.autoAttachTimer, 5000)
    timer_setEnabled(self.autoAttachTimer, true)
end

function GTASAUtil:cleanUp()
    self:debug("Cleanup")
    object_destroy(self.autoAttachTimer)
end

function GTASAUtil:adjustAddress(addr)
    if type(addr) == "string" then
        addr = tonumber(addr)
    end
    if addr == nil then
        return nil
    end
    if self.gameVersionAddr[addr] ~= nil then
        return self.gameVersionAddr[addr]
    end
    return addr+self.gameVersionOffset
end

function GTASAUtil:getInteger(addr)
    return readInteger(self:adjustAddress(addr))
end

function GTASAUtil:getByte(addr)
    return readBytes(self:adjustAddress(addr), 1, false)
end

function GTASAUtil:getFloat(addr)
    return readFloat(self:adjustAddress(addr))
end

function GTASAUtil:autoAttach()
    if self:isAutoAttachEnabled() then
       self:attach(false)
    end
end

function GTASAUtil:attach(force)
    self:tryAttach("gta_sa.exe", force)
    self:tryAttach("gta-sa.exe", force)
end

function GTASAUtil:tryAttach(process, force)
    local processId = getProcessIDFromProcessName(process)
    if processId ~= nil then
       --self:debug("Check "..process..processId..getOpenedProcessID())
    end
    if (processId ~= getOpenedProcessID() or force) and processId ~= nil then
       openProcess(process)
       self.currentProcess = process
       self:debug("Opened process "..process)
       self:detectVersion()
    end
end

function GTASAUtil:detectVersion()
    self:debug("Detect version")
    self.gameVersion = ""
    self.gameVersionOffset = 0
    self.gameVersionAddr = {}

    -- Try to detect version by address
    -- (this doesn't work when CD hasn't been checked yet)
    local target = 38079
    for _,v in ipairs(self.versionsDef) do
        if v[1] ~= nil and readInteger(v[1]) == target then
            self.gameVersion = v[4]
            self.gameVersionDescription = v[5].." [detected by address]"
            self.gameVersionOffset = v[3] + getAddress(self.currentProcess)
        end
    end

    -- Detect by module size if no version detected yet
    if self.gameVersion == "" then
        local moduleSize = getModuleSize(self.currentProcess)
        for _,v in ipairs(self.versionsDef) do
            if v[2] ~= 0 and moduleSize == v[2] then
                self.gameVersion = v[4]
                self.gameVersionDescription = v[5].." [detected by module size]"
                self.gameVersionOffset = v[3] + getAddress(self.currentProcess)
            end
        end
    end

    -- Special Addresses
    if self.gameVersion == "Steam" then
        -- Steam Version needs more than an offset for some values
        local base = getAddress(self.currentProcess)
        self.gameVersionAddr[0x68B42C] = 0x702D98 + base
        self.gameVersionAddr[0x77CB84] = 0x80FD74 + base
        self.gameVersionAddr[0x773460] = 0x8002AC + base
    end

    if self.gameVersion == "" then
        self.gameVersionDescription = "Version Unknown"
    end

    self:gameVersionDetected(self.gameVersionDescription)
end

----------------------------
-- Initialize GTA:SA Util --
----------------------------

gtasa = GTASAUtil:new()
gtasa.isAutoAttachEnabled = function()
    return true
end

gtasa.gameVersionDetected = function(self, description)
    GTASAForm.GameVersion.Caption = "Game: "..description
end

gtasa.isDebugEnabled = function()
    return settings:isEnabled("DebugOutputCheckbox")
end


---------------------
-- Settings Helper --
---------------------

SettingsHelper = {}

-- Setting name should be the name of the element in the form
-- List of boolean setting names
SettingsHelper.booleanSettings = {}

-- List of string settings, each as {"settingName", "default setting"}
SettingsHelper.stringSettings = {}

---
-- Creates a new SettingsHelper object.
--
-- @param  string  settingsName: The name these settings are stored under
-- @param  form    form: The GUI where the setting elements are on
function SettingsHelper:new(settingsName, form, saveFormLocation)
    local object = {}
    setmetatable(object, self)
    self.__index = self
    object.settingsName = settingsName
    object.form = form
    object.saveFormLocation = saveFormLocation
    return object
end

function SettingsHelper:load()
    self.settings = getSettings(self.settingsName)
    for _,v in ipairs(self.booleanSettings) do
        self:setEnabled(v, self.settings.Value[v])
    end
    for _,v in ipairs(self.stringSettings) do
        local value = self.settings.Value[v[1]]
        if value == nil or value == "" then
           value = v[2]
        end
        self.form[v[1]].Text = value
    end
    if self.saveFormLocation then
        local formLocation = self.settings.Value["formLocation"]
        if formLocation ~= nil and value ~= "" then
            local x, y = string.match(formLocation, "(%d+),(%d+)")
            if x ~= nil and y ~= nil then
                self.form.setPosition(x, y)
                debug(string.format("[Settings] Set form position to %d,%d", x, y))
            end
        end
    end
end

function SettingsHelper:save()
    for _,v in ipairs(self.booleanSettings) do
        self.settings.Value[v] = self:isEnabled(v)
    end
    for _,v in ipairs(self.stringSettings) do
        self.settings.Value[v[1]] = self.form[v[1]].Text
    end
    local x, y = self.form.getPosition()
    self.settings.Value["formLocation"] = string.format("%d,%d", x, y)
end

function SettingsHelper:isEnabled(element)
    return self.form[element]:getState() == cbChecked
end

function SettingsHelper:setEnabled(element, enabled)
    if enabled == "1" then
        self.form[element]:setState(cbChecked)
    else
        self.form[element]:setState(cbUnchecked)
    end
end

function SettingsHelper:getValue(element)
    return self.form[element].Text
end

function SettingsHelper.getPath(str,sep)
    sep = sep or '/'
    return str:match("(.*"..sep..")")
end

function SettingsHelper:selectFilePath(sender, setting)
    local dialog = createSaveDialog(sender)
    local value = self:getValue(setting)
    dialog.Title = "Select file to write to (currently: "..value..")"
    dialog.InitialDir = SettingsHelper.getPath(value,"\\")
    dialog.execute()
    local file = dialog.FileName
    if file ~= nil and file ~= "" then
       self.form[setting].Text = file
    end
end

--------------------------------
-- Initialize Settings Helper --
--------------------------------

settings = SettingsHelper:new("gtasa_music", GTASAForm, true)

settings.booleanSettings = {
    "BeepCheckbox",
    "DebugOutputCheckbox",
    "HotkeyCheckbox"
}

settings.stringSettings = {
    {"HotkeyMute",""},
    {"HotkeyUnmute",""}
}

------------
-- Muting --
------------

local locations = {
    {"Four Dragons", 1958.0, 1017.1, 992.5, 80},
    {"Caligulas", 2236.0, 1630.6, 1008.4, 120},
    {"Bloodbowl", -1389.4, 993.2, 1023.8, 200},
    {"LS Stadium", -1388.9, -223.6, 1043.2, 200},
    {"Lowrider Dance", 1793.2, -1905.6, 13.5, 40, "sweet6"},
    {"Beach Dance", 530.4, -1889.5, 3.3, 40, "music1"},
    {"Saint Marks", -789.6, 504.9, 1371.7, 20}
}

function getActiveThreads(amount)
    local addr = gtasa:getInteger("0x68B42C")
    local output = {}
    for i = 0, amount, 1 do
        if addr == nil then
            break
        end
        local threadname = readString(addr+8, 10, false)
        if threadname == nil then
            break
        end
        table.insert(output, {addr=addr, name=threadname})
        -- Get next one
        addr = readInteger(addr)
    end
    return output
end

function isActiveThread(name)
    local threads = getActiveThreads(10)
    for _, thread in ipairs(threads) do
        if thread.name == name then
            return true
        end
    end
    return false
end

function getPlayerXYZ()
    local addr = gtasa:getInteger("0x77CD98")
    if addr == nil then
       return nil
    end
    addr = readInteger(addr+20)
    if addr == nil then
        return nil
    end
    local x = readFloat(addr+48)
    local y = readFloat(addr+52)
    local z = readFloat(addr+56)
    return x,y,z
end

function calculateDistance(x, y, z, cx, cy, cz)
    return math.sqrt((cx - x)^2 + (cy - y)^2 + (cz - z)^2)
end

local lastChangedTime = 0
local prevMute = false

function checkLocation()
    local x, y, z = getPlayerXYZ()
    if x == nil or y == nil or z == nil then
        return
    end

    local mute = false
    local closestLocation = nil
    local closestDistance = -1
    for _,location in ipairs(locations) do
        local cx = location[2]
        local cy = location[3]
        local cz = location[4]
        local radius = location[5]
        local thread = location[6]
        if prevMute then
            -- Unmute further away, to prevent constant mute/unmute
            radius = radius + 20
        end
        local distance = calculateDistance(x, y, z, cx, cy, cz)
        if distance &lt; radius then
            if thread == nil or isActiveThread(thread) then
                mute = true
            end
        end

        if closestDistance == -1 or distance &lt; closestDistance then
            closestDistance = distance
            closestLocation = location
        end
    end

    -- Actual muting/unmuting
    if mute ~= prevMute then
        setMute(mute)
        lastChangedTime = os.clock()
    end
    prevMute = mute

    -- Create status output
    local state = "Muted"
    if not mute then
        state = "Unmuted"
    end
    if os.clock() - lastChangedTime &lt; 4 then
        state = "**"..state.."**"
    end
    local thread = closestLocation[6]
    if thread ~= nil then thread = "/"..thread else thread = "" end
    local name = closestLocation[1]
    local radius = closestLocation[5]
    updateState(string.format("%s (%s/%.f/%.f%s)",
        state, name, closestDistance, radius, thread))
end

function setMute(mute)
    if mute then
        triggerHotkey(mute)
        sleep(50)
        beep()
    else
        beep()
        sleep(100)
        beep()
        sleep(700)
        triggerHotkey(mute)
    end
end

function triggerHotkey(mute)
    local hotkey
    if mute then
        hotkey = _G["VK_"..settings:getValue("HotkeyMute")]
    else
        hotkey = _G["VK_"..settings:getValue("HotkeyUnmute")]
    end
    if settings:isEnabled("HotkeyCheckbox") and hotkey ~= nil then
        doKeyPress(hotkey)
    end
end

function updateState(state)
    GTASAForm.CurrentState.Caption = state
end

------------------
-- Timer / Init --
------------------

local slowTimer

function slowTimerCallback()
    local hotkeyEnabled = settings:isEnabled("HotkeyCheckbox")
    local beepEnabled = settings:isEnabled("BeepCheckbox")
    local debugEnabled = settings:isEnabled("DebugOutputCheckbox")
    if hotkeyEnabled or beepEnabled then
        if not debugEnabled then
            -- Not debugging, call protected and just stop on error
            local success, error = pcall(checkLocation)
            if not success then
                object_destroy(slowTimer)
                updateState("Error: "..tostring(error))
            end
        else
            -- Debugging, run normally with chance of error window popping up
            checkLocation()
        end
    else
        updateState("Inactive")
    end
end

function init()
    fillKeys(GTASAForm.HotkeyMute)
    fillKeys(GTASAForm.HotkeyUnmute)
    settings:load()

    slowTimer = createTimer(nil, false)
    timer_onTimer(slowTimer, slowTimerCallback)
    timer_setInterval(slowTimer, 250)
    timer_setEnabled(slowTimer, true)

    gtasa:init()
    gtasa:attach(true)
end

local function starts_with(str, start)
   return str:sub(1, #start) == start
end

-- Fill a combo box with all defined key names (variables starting with "VK_")
function fillKeys(combo)
    combo:clear()
    local keys = {}
    for key,_ in pairs(_G) do
        if starts_with(key, "VK_") then
            table.insert(keys, key:sub(4))
        end
    end
    table.sort(keys, function(a,b)
        if a:len() == b:len() then
            return a &lt; b
        end
        return a:len() &lt; b:len()
    end)
    for _,key in ipairs(keys) do
        combo.Items.Add(key)
    end
end

-- Show GUI and init stuff
form_show(GTASAForm)
init()

-------------------
-- GUI Functions --
-------------------

GTASAForm.onClose = function(sender)
    debug("Closed")
    object_destroy(slowTimer)
    gtasa:cleanUp()
    settings:save()
    -- Only for standalone version
    --closeCE()
    return caHide
end

function TestMuteButton(sender)
    setMute(true)
end

function TestUnmuteButton(sender)
    setMute(false)
end

function CopyPlayerCoordinatesClick(sender)
    local x, y, z = getPlayerXYZ()
    if x ~= nil then
        writeToClipboard(string.format("%.1f, %.1f, %.1f",
            x, y, z))
    else
        writeToClipboard("Coordinates currently not available")
    end
end
</LuaScript>
</CheatTable>
