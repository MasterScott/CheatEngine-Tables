<?xml version="1.0" encoding="utf-8"?>
<CheatTable CheatEngineTableVersion="18">
  <Forms>
    <GTASAForm Class="TCEForm" Encoding="Ascii85">=O1Da,cppuENS)y/!RoT^%G.9w(SrS]RzX$ilS^b*FUJnJI)Y5CBha+GNJNO$1@:ZkI_VPp=By3dV)IM3sTf8R[Z4II=*V)1,cr:^jdvw]s,a:VYE)*8ADc1xO/(DH6(dUR7z!,e*121GiG1*^H51PgAbFxB-7]%/?b]0NJch=zRewYjxxu)MC+ZPcc}Qk97+4Hu2$rM%@W^gupD)]]CN,,gJGRHL1scGmeCNo$GZIrf4[Rh^XV-5yB,;Mv{h=68{vXJv@273;D{0zRl}Kfu9!/B;8xRPny$s%r9;jq(aXQhwdbRGG=hJ-oNkZ1x?_GB#,J,--^phMoB?yK+aVTunVwtWzR$0pOs3JYMM?sda+cJ!2n{.1A3L#,PeLEb$Vcm8g$qygq1i:vw=f]zzUH(+5r3f_I@LG/yU5?XAVnZ0AY}vsKz4!b0oey}0OSzJ5fBMT1(9o!3Pb@N0@{6P8IT%}={5Amq5]P^X#i.gX#sf,L/6D(F?Uszya93!/O0ZBAV0v.NeN3C%MO-ZEPGh=u@eDI#Bu}n=G[{ZY88?71FMr#QB*.Sl_^89s$Eg-iE3X_2ckL?*e%-?AyF0+Wg$?)5?nPyqza@?R!fIeMUr1Zs?gnnK/Z3UTUa.i3Zzu!#K8KzhU0am)S{q+xxf*kjHG2%ku+rF.Y[,EwRHs;t:2HYripV{=eq,LTEwEC*lgqrZ%MKOAWIEdQ30xosu/X;+51@r+ebd#wXm%/bVV{(*JP08#b_2^Y*5?v*_x8H;nJZ9kU@:MA+o0-8wO56rmD!bx*?O_6uFISWYkLAFq#d;*MKL2uB%P-UJxy+T8xQOOq63^Cnk1dVlO84W8xqt4rAg7GTLaZtQuREt,!R9*;7X;RvVA$4XLG^H4UWN6,?HIr_d-{S^hSj$mvQ.)j:p*B[@3lW.1mq%AmG$^gGUqO6LWMIK^Cj38O@5GYOx?N%$q-zU15gEZ@^I%wfJ(0+roV*nJ{4k_gThBi{ylUYt[!e8Lfl^7Y7knC=p3/e!Og-looM$A[1}A9}X;vEsqNqCImsWDezyc(0GA*-gS1iLT#cv;UiC-o)@nzIeiT;svEd?T+K?g{0nG]#1q,U#yxn].iTa?iQbBE-O}ZG#z}Tbo-e)WLI0JSW55l8*0ZR8(kQ-(LpRI/_]o_oq]_Vo0$Xi)^@V?#p3.$Vf*k[k^0h!r1+Y(@z:XP)Q;$Ow8nUsK0x[C]./z_yj*i+j1A*#-#uTK@UvD_n[q;dNvv_G%hsvsSYu?T8yknV3i)3bKx^h5j,ju{qrQEOn0XvALu75lt0(NPzVoTT+L0}J.pwt2zAI5]liHWmVqV_pLuv,:(4nJZjx]JM/]{{1urCw)z@vS2sM5M]BFMRJXT(=fE{g*m2,wk{!v?Qz/}4i6T,dz^-E,7t4$gG+#$oRLqH,R!A?o!ledqj@7*R3warAihIUbEJCCAu(E1Wr_rL7].XEC335l7m(rKV-M%:3O,j=j_%fV/f#5LV/Uz)dGB8--}_:UokBY^ka,R[(6SUElth9T*N/*GWHD?+5Y]xwL9x*NPk^ws)u$-VI}@^)2!#?n[QcUuU-46[pjyENW0P@lQQ-54abfl}m/jQ-CMp++p%%tnDb*F[wkkCf)Qwhc]AvxORJ^bA?xGSRR/D;5_;x.n3xd/rVUs/FQiOKqw0N=lEl+%v/4@jVjSOir:i0m95db@v3pkp/c]a+R/?wqieWiXv]+kQ7#I))F9UKXeMHVo362,0@3C$M$cs=qIqq5Vh7g4:qin);-W!yu5V(g*:qeUuDIqEcf9RV;F8,tu)(:GT#NH@[S__?Wu4%v8TiA%k0Wcr1u-2}AOEI)Hks8#+v.kV/N4]3FO9zwa_h##Di/dibIi[wMOzd(157J:%L6;p%*#K6It:mgd5HPT)b:@#cRggxez?-BT1bZ_%wu-v^{p%L1(}POjWNg6e.YYNG}$cliOh$$Q4GpFJbN+*y_Dq$#B;}@),u$*[4S=d.amcL^^R</GTASAForm>
  </Forms>
  <CheatEntries/>
  <UserdefinedSymbols/>
  <LuaScript>local version = "1.0"
local standalone = false

function debug(text)
    if settings:isEnabled("DebugOutputCheckbox") then
        print(text)
    end
end

----------------------
-- GTA:SA Utilities --
----------------------
GTASAUtil = {}

-- The following functions should be added to return true if these features
-- should be enabled:
--
-- self:isAutoAttachEnabled()
-- self:gameVersionDetected()
-- self:isDebugEnabled()
--
-- The following function is called when the game version has been detected:
--
-- self:gameVersionDetected(self.gameVersionDescription)


-- What to add to the relative 1.0 address to get the address for the current
-- version (e.g. also contains the process address, usually 0x400000).
GTASAUtil.gameVersionOffset = 0

-- Contains special addresses, that require more than an offset to work.
-- The key is the normal 1.0 address, the value the absolute address.
GTASAUtil.gameVersionAddr = {}

GTASAUtil.versionsDef = {
    {"008245BC",18313216,0,"1.0","1.0"},
    {"0082457C",18313216,0,"1.0","1.0"},
    {"0082533C",34471936,0x2680,"1.01","1.01"},
    {"008252FC",34471936,0x2680,"1.01","1.01"},
    {nil,17985536,0x2680,"2.0","2.0"},
    {"0085EC4A",9691136,0x75130,"3.0 Steam","3.0 Steam"},
    {"0085DEDA",0,0x75770,"1.01 Steam","1.01 Steam?"},
    -- The steam version needs more than an offset for some addresses
    -- (specific replacement addresses defined in detectVersion())
    {nil,9981952,0x77970,"Steam","Steam"}
}

GTASAUtil.gameVersion = ""
GTASAUtil.gameVersionDescription = ""

function GTASAUtil:new()
    local object = {}
    setmetatable(object, self)
    self.__index = self
    return object
end

function GTASAUtil:debug(text)
    if self:isDebugEnabled() then
        print("[GTASAUtil] "..text)
    end
end

function GTASAUtil:init()
    self.autoAttachTimer = createTimer(nil, false)
    timer_onTimer(self.autoAttachTimer, function() self:autoAttach() end)
    timer_setInterval(self.autoAttachTimer, 5000)
    timer_setEnabled(self.autoAttachTimer, true)
end

function GTASAUtil:cleanUp()
    self:debug("Cleanup")
    object_destroy(self.autoAttachTimer)
end

function GTASAUtil:adjustAddress(addr)
    if type(addr) == "string" then
        addr = tonumber(addr)
    end
    if addr == nil then
        return nil
    end
    if self.gameVersionAddr[addr] ~= nil then
        return self.gameVersionAddr[addr]
    end
    return addr+self.gameVersionOffset
end

function GTASAUtil:getInteger(addr)
    return readInteger(self:adjustAddress(addr))
end

function GTASAUtil:getByte(addr)
    return readBytes(self:adjustAddress(addr), 1, false)
end

function GTASAUtil:getFloat(addr)
    return readFloat(self:adjustAddress(addr))
end

function GTASAUtil:autoAttach()
    if self:isAutoAttachEnabled() then
       self:attach(false)
    end
end

function GTASAUtil:attach(force)
    -- Try to read from current process to check if still available
    local testRead = readInteger(self.currentProcess)
    if testRead == nil or force then
        local names = {"gta_sa.exe", "gta-sa.exe"}
        for _,name in ipairs(names) do
            if self:tryAttach(name, force) then
                return
            end
        end
        self:gameNotFound()
    end
end

function GTASAUtil:tryAttach(process, force)
    --self:debug("Try "..process)
    local processId = getProcessIDFromProcessName(process)
    if processId == nil then
        return false
    end
    --self:debug("Check "..process.." "..processId.." "..getOpenedProcessID())
    if processId ~= getOpenedProcessID() or force then
       openProcess(process)
       self.currentProcess = process
       self:debug("Opened process "..process)
       self:detectVersion()
    end
    return true
end

function GTASAUtil:detectVersion()
    self:debug("Detect version")
    self.gameVersion = ""
    self.gameVersionOffset = 0
    self.gameVersionAddr = {}

    -- Try to detect version by address
    -- (this doesn't work when CD hasn't been checked yet)
    local target = 38079
    for _,v in ipairs(self.versionsDef) do
        if v[1] ~= nil and readInteger(v[1]) == target then
            self.gameVersion = v[4]
            self.gameVersionDescription = v[5].." [detected by address]"
            self.gameVersionOffset = v[3] + getAddress(self.currentProcess)
        end
    end

    -- Detect by module size if no version detected yet
    if self.gameVersion == "" then
        local moduleSize = getModuleSize(self.currentProcess)
        for _,v in ipairs(self.versionsDef) do
            if v[2] ~= 0 and moduleSize == v[2] then
                self.gameVersion = v[4]
                self.gameVersionDescription = v[5].." [detected by module size]"
                self.gameVersionOffset = v[3] + getAddress(self.currentProcess)
            end
        end
    end

    -- Special Addresses
    if self.gameVersion == "Steam" then
        -- Steam Version needs more than an offset for some values
        local base = getAddress(self.currentProcess)
        -- Pointer to first active SCM thread
        self.gameVersionAddr[0x68B42C] = 0x702D98 + base
        -- Call timer related
        self.gameVersionAddr[0x77CB84] = 0x80FD74 + base
        -- Action key (holding call related)
        self.gameVersionAddr[0x773460] = 0x8002AC + base
        -- Player pointer (probably)
        self.gameVersionAddr[0x77CD98] = 0x8100D0 + base
    end

    if self.gameVersion == "" then
        self.gameVersionDescription = "Version Unknown"
    end

    self:gameVersionDetected(self.gameVersionDescription)
end

----------------------------
-- Initialize GTA:SA Util --
----------------------------

gtasa = GTASAUtil:new()
gtasa.isAutoAttachEnabled = function()
    return true
end

gtasa.gameVersionDetected = function(self, description)
    GTASAForm.GameVersion.Caption = "Game: "..description
end

gtasa.gameNotFound = function(self)
    GTASAForm.GameVersion.Caption = "Game process not found"
end

gtasa.isDebugEnabled = function()
    return settings:isEnabled("DebugOutputCheckbox")
end


---------------------
-- Settings Helper --
---------------------

SettingsHelper = {}

-- Setting name should be the name of the element in the form
-- List of boolean setting names
SettingsHelper.booleanSettings = {}

-- List of string settings, each as {"settingName", "default setting"}
SettingsHelper.stringSettings = {}

---
-- Creates a new SettingsHelper object.
--
-- @param  string  settingsName: The name these settings are stored under
-- @param  form    form: The GUI where the setting elements are on
function SettingsHelper:new(settingsName, form, saveFormLocation)
    local object = {}
    setmetatable(object, self)
    self.__index = self
    object.settingsName = settingsName
    object.form = form
    object.saveFormLocation = saveFormLocation
    return object
end

function SettingsHelper:load()
    self.settings = getSettings(self.settingsName)
    for _,v in ipairs(self.booleanSettings) do
        self:setEnabled(v, self.settings.Value[v])
    end
    for _,v in ipairs(self.stringSettings) do
        local value = self.settings.Value[v[1]]
        if value == nil or value == "" then
           value = v[2]
        end
        self.form[v[1]].Text = value
    end
    if self.saveFormLocation then
        local formLocation = self.settings.Value["formLocation"]
        if formLocation ~= nil and value ~= "" then
            local x, y = string.match(formLocation, "(%d+),(%d+)")
            if x ~= nil and y ~= nil then
                self.form.setPosition(x, y)
                debug(string.format("[Settings] Set form position to %d,%d", x, y))
            end
        end
    end
end

function SettingsHelper:save()
    for _,v in ipairs(self.booleanSettings) do
        self.settings.Value[v] = self:isEnabled(v)
    end
    for _,v in ipairs(self.stringSettings) do
        self.settings.Value[v[1]] = self.form[v[1]].Text
    end
    local x, y = self.form.getPosition()
    self.settings.Value["formLocation"] = string.format("%d,%d", x, y)
end

function SettingsHelper:isEnabled(element)
    return self.form[element]:getState() == cbChecked
end

function SettingsHelper:setEnabled(element, enabled)
    if enabled == "1" then
        self.form[element]:setState(cbChecked)
    else
        self.form[element]:setState(cbUnchecked)
    end
end

function SettingsHelper:getValue(element)
    return self.form[element].Text
end

function SettingsHelper.getPath(str,sep)
    sep = sep or '/'
    return str:match("(.*"..sep..")")
end

function SettingsHelper:selectFilePath(sender, setting)
    local dialog = createSaveDialog(sender)
    local value = self:getValue(setting)
    dialog.Title = "Select file to write to (currently: "..value..")"
    dialog.InitialDir = SettingsHelper.getPath(value,"\\")
    dialog.execute()
    local file = dialog.FileName
    if file ~= nil and file ~= "" then
       self.form[setting].Text = file
    end
end

--------------------------------
-- Initialize Settings Helper --
--------------------------------

settings = SettingsHelper:new("gtasa_music", GTASAForm, true)

settings.booleanSettings = {
    "BeepCheckbox",
    "DebugOutputCheckbox",
    "HotkeyCheckbox"
}

settings.stringSettings = {
    {"HotkeyMute",""},
    {"HotkeyUnmute",""}
}

------------
-- Muting --
------------

local locations = {
    {"Four Dragons", 1958.0, 1017.1, 992.5, 80},
    {"Caligulas", 2236.0, 1630.6, 1008.4, 120},
    {"Bloodbowl", -1389.4, 993.2, 1023.8, 200},
    {"LS Stadium", -1388.9, -223.6, 1043.2, 200},
    {"Lowrider Dance", 1793.2, -1905.6, 13.5, 40, "sweet6"},
    {"Beach Dance", 530.4, -1889.5, 3.3, 40, "music1"},
    {"Saint Marks", -789.6, 504.9, 1371.7, 20}
}

function getActiveThreads(amount)
    local addr = gtasa:getInteger("0x68B42C")
    local output = {}
    for i = 0, amount, 1 do
        if addr == nil then
            break
        end
        local threadname = readString(addr+8, 10, false)
        if threadname == nil then
            break
        end
        table.insert(output, {addr=addr, name=threadname})
        -- Get next one
        addr = readInteger(addr)
    end
    return output
end

function isActiveThread(name)
    local threads = getActiveThreads(10)
    for _, thread in ipairs(threads) do
        if thread.name == name then
            return true
        end
    end
    return false
end

function getPlayerXYZ()
    local addr = gtasa:getInteger("0x77CD98")
    if addr == nil then
       return nil
    end
    addr = readInteger(addr+20)
    if addr == nil then
        return nil
    end
    local x = readFloat(addr+48)
    local y = readFloat(addr+52)
    local z = readFloat(addr+56)
    return x,y,z
end

function calculateDistance(x, y, z, cx, cy, cz)
    return math.sqrt((cx - x)^2 + (cy - y)^2 + (cz - z)^2)
end

local lastChangedTime = 0
local prevMute = false

function checkLocation()
    local x, y, z = getPlayerXYZ()
    if x == nil or y == nil or z == nil then
        updateState("Game not ready")
        return
    end

    local mute = false
    local closestLocation = nil
    local closestDistance = -1
    for _,location in ipairs(locations) do
        local cx = location[2]
        local cy = location[3]
        local cz = location[4]
        local radius = location[5]
        local thread = location[6]
        if prevMute then
            -- Unmute further away, to prevent constant mute/unmute
            radius = radius + 20
        end
        local distance = calculateDistance(x, y, z, cx, cy, cz)
        if distance &lt; radius then
            if thread == nil or isActiveThread(thread) then
                mute = true
            end
        end

        if closestDistance == -1 or distance &lt; closestDistance then
            closestDistance = distance
            closestLocation = location
        end
    end

    -- Actual muting/unmuting
    if mute ~= prevMute then
        setMute(mute)
        lastChangedTime = os.clock()
    end
    prevMute = mute

    -- Create status output
    local state = "Muted"
    if not mute then
        state = "Unmuted"
    end
    if os.clock() - lastChangedTime &lt; 4 then
        state = "**"..state.."**"
    end
    local thread = closestLocation[6]
    if thread ~= nil then thread = "/"..thread else thread = "" end
    local name = closestLocation[1]
    local radius = closestLocation[5]
    updateState(string.format("%s (%s/%.f/%.f%s)",
        state, name, closestDistance, radius, thread))
end

function setMute(mute)
    if settings:isEnabled("BeepCheckbox") then
        if mute then
            triggerHotkey(mute)
            sleep(50)
            beep()
        else
            beep()
            sleep(100)
            beep()
            sleep(700)
            triggerHotkey(mute)
        end
    else
        triggerHotkey(mute)
    end
end

function triggerHotkey(mute)
    local hotkey
    if mute then
        hotkey = _G["VK_"..settings:getValue("HotkeyMute")]
    else
        hotkey = _G["VK_"..settings:getValue("HotkeyUnmute")]
    end
    if settings:isEnabled("HotkeyCheckbox") and hotkey ~= nil then
        doKeyPress(hotkey)
    end
end

function updateState(state)
    GTASAForm.CurrentState.Caption = state
end

------------------
-- Timer / Init --
------------------

local slowTimer

function slowTimerCallback()
    local hotkeyEnabled = settings:isEnabled("HotkeyCheckbox")
    local beepEnabled = settings:isEnabled("BeepCheckbox")
    local debugEnabled = settings:isEnabled("DebugOutputCheckbox")
    if hotkeyEnabled or beepEnabled then
        if not debugEnabled then
            -- Not debugging, call protected and just stop on error
            local success, error = pcall(checkLocation)
            if not success then
                object_destroy(slowTimer)
                updateState("Error: "..tostring(error))
            end
        else
            -- Debugging, run normally with chance of error window popping up
            checkLocation()
        end
    else
        updateState("Inactive")
    end
end

function init()
    local versionInfo = GTASAForm.DebugOutputCheckbox.Hint.."\n\nYou are using version "..version
    GTASAForm.DebugOutputCheckbox.Hint = versionInfo

    fillKeys(GTASAForm.HotkeyMute)
    fillKeys(GTASAForm.HotkeyUnmute)
    settings:load()

    slowTimer = createTimer(nil, false)
    timer_onTimer(slowTimer, slowTimerCallback)
    timer_setInterval(slowTimer, 250)
    timer_setEnabled(slowTimer, true)

    gtasa:init()
    gtasa:attach(true)
end

local function starts_with(str, start)
   return str:sub(1, #start) == start
end

-- Fill a combo box with all defined key names (variables starting with "VK_")
function fillKeys(combo)
    combo:clear()
    local keys = {}
    for key,_ in pairs(_G) do
        if starts_with(key, "VK_") then
            table.insert(keys, key:sub(4))
        end
    end
    table.sort(keys, function(a,b)
        if a:len() == b:len() then
            return a &lt; b
        end
        return a:len() &lt; b:len()
    end)
    for _,key in ipairs(keys) do
        combo.Items.Add(key)
    end
end

-- Show GUI and init stuff
form_show(GTASAForm)
init()

-------------------
-- GUI Functions --
-------------------

GTASAForm.onClose = function(sender)
    debug("Closed")
    object_destroy(slowTimer)
    gtasa:cleanUp()
    settings:save()
    -- Only for standalone version
    if standalone then
        closeCE()
    end
    return caHide
end

function TestMuteButton(sender)
    setMute(true)
end

function TestUnmuteButton(sender)
    setMute(false)
end

function CopyPlayerCoordinatesClick(sender)
    local x, y, z = getPlayerXYZ()
    if x ~= nil then
        writeToClipboard(string.format("%.1f, %.1f, %.1f",
            x, y, z))
    else
        writeToClipboard("Coordinates currently not available")
    end
end
</LuaScript>
</CheatTable>
